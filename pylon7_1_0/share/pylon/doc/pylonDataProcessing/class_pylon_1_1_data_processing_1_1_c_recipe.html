<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pylon Application SDK: Programmer&#39;s Guide and API Reference for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_pylon.html">Pylon</a></li><li class="navelem"><a class="el" href="namespace_pylon_1_1_data_processing.html">DataProcessing</a></li><li class="navelem"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html">CRecipe</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_pylon_1_1_data_processing_1_1_c_recipe-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Pylon::DataProcessing::CRecipe Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides convenient access to a data processing design described by a recipe file.  
 <a href="class_pylon_1_1_data_processing_1_1_c_recipe.html#details">More...</a></p>

<p><code>#include &lt;pylondataprocessing/Recipe.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a29cc39040b471c8f0e5a19244d6f488a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a29cc39040b471c8f0e5a19244d6f488a">CRecipe</a> ()</td></tr>
<tr class="memdesc:a29cc39040b471c8f0e5a19244d6f488a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> object with no recipe loaded.  <a href="#a29cc39040b471c8f0e5a19244d6f488a">More...</a><br /></td></tr>
<tr class="separator:a29cc39040b471c8f0e5a19244d6f488a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ef328bf834b8afafea7607321d0f7e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a88ef328bf834b8afafea7607321d0f7e">~CRecipe</a> ()</td></tr>
<tr class="memdesc:a88ef328bf834b8afafea7607321d0f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> object.  <a href="#a88ef328bf834b8afafea7607321d0f7e">More...</a><br /></td></tr>
<tr class="separator:a88ef328bf834b8afafea7607321d0f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade704260929c747515bb726e7f29612f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ade704260929c747515bb726e7f29612f">Load</a> (const String_t &amp;filename)</td></tr>
<tr class="memdesc:ade704260929c747515bb726e7f29612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a recipe from disk and creates the objects of the design described by the recipe.  <a href="#ade704260929c747515bb726e7f29612f">More...</a><br /></td></tr>
<tr class="separator:ade704260929c747515bb726e7f29612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4975c952bae69337e6b7e74c38b3f15"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ad4975c952bae69337e6b7e74c38b3f15">LoadFromBinary</a> (const void *pBuffer, size_t bufferSize)</td></tr>
<tr class="memdesc:ad4975c952bae69337e6b7e74c38b3f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a recipe from binary buffer and creates the objects of the design described by the recipe.  <a href="#ad4975c952bae69337e6b7e74c38b3f15">More...</a><br /></td></tr>
<tr class="separator:ad4975c952bae69337e6b7e74c38b3f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c575281e0357133c1165ec72fcacf5b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a9c575281e0357133c1165ec72fcacf5b">IsLoaded</a> () const</td></tr>
<tr class="memdesc:a9c575281e0357133c1165ec72fcacf5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a recipe is loaded.  <a href="#a9c575281e0357133c1165ec72fcacf5b">More...</a><br /></td></tr>
<tr class="separator:a9c575281e0357133c1165ec72fcacf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade90b70669f92e86760d60c20a5be771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ade90b70669f92e86760d60c20a5be771">PreAllocateResources</a> ()</td></tr>
<tr class="memdesc:ade90b70669f92e86760d60c20a5be771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional method to pre-allocate resources.  <a href="#ade90b70669f92e86760d60c20a5be771">More...</a><br /></td></tr>
<tr class="separator:ade90b70669f92e86760d60c20a5be771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a89e0690875436aa185b22854cd8747"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3a89e0690875436aa185b22854cd8747">Start</a> ()</td></tr>
<tr class="memdesc:a3a89e0690875436aa185b22854cd8747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares the data processing and allocates resources required by the design.  <a href="#a3a89e0690875436aa185b22854cd8747">More...</a><br /></td></tr>
<tr class="separator:a3a89e0690875436aa185b22854cd8747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a045db5cb05b34c9f421a432c9abe33"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a0a045db5cb05b34c9f421a432c9abe33">IsStarted</a> () const</td></tr>
<tr class="memdesc:a0a045db5cb05b34c9f421a432c9abe33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about the recipe being started.  <a href="#a0a045db5cb05b34c9f421a432c9abe33">More...</a><br /></td></tr>
<tr class="separator:a0a045db5cb05b34c9f421a432c9abe33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aac836a86698a2899f1db0cdaaef420"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a5aac836a86698a2899f1db0cdaaef420">Stop</a> (unsigned int timeoutMs=waitForever)</td></tr>
<tr class="memdesc:a5aac836a86698a2899f1db0cdaaef420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the data processing and deallocates all resources allocated at start.  <a href="#a5aac836a86698a2899f1db0cdaaef420">More...</a><br /></td></tr>
<tr class="separator:a5aac836a86698a2899f1db0cdaaef420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ccde1d97df744b229e737b737c8d09"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a56ccde1d97df744b229e737b737c8d09">DeallocateResources</a> ()</td></tr>
<tr class="memdesc:a56ccde1d97df744b229e737b737c8d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates all resources used by the recipe.  <a href="#a56ccde1d97df744b229e737b737c8d09">More...</a><br /></td></tr>
<tr class="separator:a56ccde1d97df744b229e737b737c8d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be612910e571e5b17c29c761f94d34d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3be612910e571e5b17c29c761f94d34d">Unload</a> ()</td></tr>
<tr class="memdesc:a3be612910e571e5b17c29c761f94d34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads the recipe currently loaded.  <a href="#a3be612910e571e5b17c29c761f94d34d">More...</a><br /></td></tr>
<tr class="separator:a3be612910e571e5b17c29c761f94d34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e67cf77c109f3f48f96ccc356cc20d9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_pylon_1_1_data_processing_1_1_i_parameter_collection.html">IParameterCollection</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a6e67cf77c109f3f48f96ccc356cc20d9">GetParameters</a> ()</td></tr>
<tr class="memdesc:a6e67cf77c109f3f48f96ccc356cc20d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a parameter collection to access the parameters of the recipe.  <a href="#a6e67cf77c109f3f48f96ccc356cc20d9">More...</a><br /></td></tr>
<tr class="separator:a6e67cf77c109f3f48f96ccc356cc20d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327e0ed4bfe8f223d8e4aeeb38b70bc4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a327e0ed4bfe8f223d8e4aeeb38b70bc4">SetRecipeContext</a> (intptr_t context)</td></tr>
<tr class="memdesc:a327e0ed4bfe8f223d8e4aeeb38b70bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a context.  <a href="#a327e0ed4bfe8f223d8e4aeeb38b70bc4">More...</a><br /></td></tr>
<tr class="separator:a327e0ed4bfe8f223d8e4aeeb38b70bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b485de46abb1dc4f1bd6abf4a3bdb95"><td class="memItemLeft" align="right" valign="top">virtual intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4b485de46abb1dc4f1bd6abf4a3bdb95">GetRecipeContext</a> () const</td></tr>
<tr class="memdesc:a4b485de46abb1dc4f1bd6abf4a3bdb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the context.  <a href="#a4b485de46abb1dc4f1bd6abf4a3bdb95">More...</a><br /></td></tr>
<tr class="separator:a4b485de46abb1dc4f1bd6abf4a3bdb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a6b99b08f637b0dbf225ebb1a4e9ff"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a99a6b99b08f637b0dbf225ebb1a4e9ff">HasInput</a> (const String_t &amp;inputFullName) const</td></tr>
<tr class="memdesc:a99a6b99b08f637b0dbf225ebb1a4e9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an input pin is available.  <a href="#a99a6b99b08f637b0dbf225ebb1a4e9ff">More...</a><br /></td></tr>
<tr class="separator:a99a6b99b08f637b0dbf225ebb1a4e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93725db38c5411cdfb576dcf0d7a992d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a93725db38c5411cdfb576dcf0d7a992d">HasOutput</a> (const String_t &amp;outputFullName) const</td></tr>
<tr class="memdesc:a93725db38c5411cdfb576dcf0d7a992d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an output pin is available.  <a href="#a93725db38c5411cdfb576dcf0d7a992d">More...</a><br /></td></tr>
<tr class="separator:a93725db38c5411cdfb576dcf0d7a992d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7861a74e827b218bdefd5fd2c564a41"><td class="memItemLeft" align="right" valign="top">virtual String_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ab7861a74e827b218bdefd5fd2c564a41">GetInputTypeName</a> (const String_t &amp;inputFullName) const</td></tr>
<tr class="memdesc:ab7861a74e827b218bdefd5fd2c564a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type name of the input pin.  <a href="#ab7861a74e827b218bdefd5fd2c564a41">More...</a><br /></td></tr>
<tr class="separator:ab7861a74e827b218bdefd5fd2c564a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621e1b8fad3dd2a8b29e7fd0ae19ca02"><td class="memItemLeft" align="right" valign="top">virtual String_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a621e1b8fad3dd2a8b29e7fd0ae19ca02">GetOutputTypeName</a> (const String_t &amp;outputFullName) const</td></tr>
<tr class="memdesc:a621e1b8fad3dd2a8b29e7fd0ae19ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type name of the output pin.  <a href="#a621e1b8fad3dd2a8b29e7fd0ae19ca02">More...</a><br /></td></tr>
<tr class="separator:a621e1b8fad3dd2a8b29e7fd0ae19ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0f7764bdbbf30e65b9ea5e4214eee5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_pylon_1_1_data_processing.html#acba3cdc7c343bca3abe5bb6321249e55">EVariantDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3b0f7764bdbbf30e65b9ea5e4214eee5">GetInputType</a> (const String_t &amp;inputFullName) const</td></tr>
<tr class="memdesc:a3b0f7764bdbbf30e65b9ea5e4214eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variant data type of the input pin.  <a href="#a3b0f7764bdbbf30e65b9ea5e4214eee5">More...</a><br /></td></tr>
<tr class="separator:a3b0f7764bdbbf30e65b9ea5e4214eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfcdbdf21de387fc6b58ff0279d6e51"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_pylon_1_1_data_processing.html#acba3cdc7c343bca3abe5bb6321249e55">EVariantDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#aadfcdbdf21de387fc6b58ff0279d6e51">GetOutputType</a> (const String_t &amp;outputFullName) const</td></tr>
<tr class="memdesc:aadfcdbdf21de387fc6b58ff0279d6e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variant data type of the output pin.  <a href="#aadfcdbdf21de387fc6b58ff0279d6e51">More...</a><br /></td></tr>
<tr class="separator:aadfcdbdf21de387fc6b58ff0279d6e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72bb3d2294a694e563c9dd4b3f9ecc2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#af72bb3d2294a694e563c9dd4b3f9ecc2">CanTriggerUpdate</a> () const</td></tr>
<tr class="memdesc:af72bb3d2294a694e563c9dd4b3f9ecc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether triggering an update is possible.  <a href="#af72bb3d2294a694e563c9dd4b3f9ecc2">More...</a><br /></td></tr>
<tr class="separator:af72bb3d2294a694e563c9dd4b3f9ecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a35e407a87c9e1ccfcb37ec31b8aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a249a35e407a87c9e1ccfcb37ec31b8aa">TriggerUpdateAsync</a> (const String_t &amp;inputFullName, <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a> value, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *pObserver=nullptr, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:a249a35e407a87c9e1ccfcb37ec31b8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an update asynchronously for a single input pin.  <a href="#a249a35e407a87c9e1ccfcb37ec31b8aa">More...</a><br /></td></tr>
<tr class="separator:a249a35e407a87c9e1ccfcb37ec31b8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad48ebe617dc0dc30b8afa255c8fb48e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#aad48ebe617dc0dc30b8afa255c8fb48e">TriggerUpdate</a> (const String_t &amp;inputFullName, <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a> value, unsigned int timeoutMs, ETimeoutHandling timeoutHandling=TimeoutHandling_ThrowException, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *pObserver=nullptr, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:aad48ebe617dc0dc30b8afa255c8fb48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an update in a blocking call for a single input pin.  <a href="#aad48ebe617dc0dc30b8afa255c8fb48e">More...</a><br /></td></tr>
<tr class="separator:aad48ebe617dc0dc30b8afa255c8fb48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1947c2a557f26a047bac2e8bc27bb7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#aec1947c2a557f26a047bac2e8bc27bb7">TriggerUpdateAsync</a> (<a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant_container.html">CVariantContainer</a> inputCollection, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *pObserver=nullptr, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:aec1947c2a557f26a047bac2e8bc27bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an update asynchronously for a number of input pins.  <a href="#aec1947c2a557f26a047bac2e8bc27bb7">More...</a><br /></td></tr>
<tr class="separator:aec1947c2a557f26a047bac2e8bc27bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6073cbb325416a05898146e79e8a667"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ab6073cbb325416a05898146e79e8a667">TriggerUpdate</a> (<a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant_container.html">CVariantContainer</a> inputCollection, unsigned int timeoutMs, ETimeoutHandling timeoutHandling=TimeoutHandling_ThrowException, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *pObserver=nullptr, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:ab6073cbb325416a05898146e79e8a667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an update in a blocking call for a number of input pins.  <a href="#ab6073cbb325416a05898146e79e8a667">More...</a><br /></td></tr>
<tr class="separator:ab6073cbb325416a05898146e79e8a667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf24f812c92e0dda89e100c61699f7e4"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#acf24f812c92e0dda89e100c61699f7e4">GetOutputNames</a> (StringList_t &amp;result) const</td></tr>
<tr class="memdesc:acf24f812c92e0dda89e100c61699f7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count and the list of names of all output pins.  <a href="#acf24f812c92e0dda89e100c61699f7e4">More...</a><br /></td></tr>
<tr class="separator:acf24f812c92e0dda89e100c61699f7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf711895119c2a82bf9a0bbbfad31ee0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#adf711895119c2a82bf9a0bbbfad31ee0">RegisterOutputObserver</a> (const String_t &amp;outputFullName, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *pObserver, ERegistrationMode mode, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:adf711895119c2a82bf9a0bbbfad31ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an output observer to the list of registered output observers.  <a href="#adf711895119c2a82bf9a0bbbfad31ee0">More...</a><br /></td></tr>
<tr class="separator:adf711895119c2a82bf9a0bbbfad31ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0d02363ba4c13b26af72d3a9790d7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a1b0d02363ba4c13b26af72d3a9790d7e">RegisterOutputObserver</a> (const StringList_t &amp;outputFullNames, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *pObserver, ERegistrationMode mode, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:a1b0d02363ba4c13b26af72d3a9790d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an output observer to the list of registered output observers.  <a href="#a1b0d02363ba4c13b26af72d3a9790d7e">More...</a><br /></td></tr>
<tr class="separator:a1b0d02363ba4c13b26af72d3a9790d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eb91753ef439806df763f3812ab739"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a39eb91753ef439806df763f3812ab739">RegisterAllOutputsObserver</a> (<a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *pObserver, ERegistrationMode mode, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:a39eb91753ef439806df763f3812ab739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an output observer to the list of registered output observers.  <a href="#a39eb91753ef439806df763f3812ab739">More...</a><br /></td></tr>
<tr class="separator:a39eb91753ef439806df763f3812ab739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42533f9952f888103f804595cac1c976"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a42533f9952f888103f804595cac1c976">UnregisterOutputObserver</a> (const String_t &amp;outputFullName, <a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *pObserver, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:a42533f9952f888103f804595cac1c976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an output observer from the list of registered output observers.  <a href="#a42533f9952f888103f804595cac1c976">More...</a><br /></td></tr>
<tr class="separator:a42533f9952f888103f804595cac1c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3fed78de3117ffdcca305cb787f65e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#aff3fed78de3117ffdcca305cb787f65e">UnregisterOutputObserver</a> (<a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *pObserver, intptr_t userProvidedId=0)</td></tr>
<tr class="memdesc:aff3fed78de3117ffdcca305cb787f65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an output observer from the list of registered output observers for all output pins.  <a href="#aff3fed78de3117ffdcca305cb787f65e">More...</a><br /></td></tr>
<tr class="separator:aff3fed78de3117ffdcca305cb787f65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfab1c3de4499541b02ce60245905d2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#abfab1c3de4499541b02ce60245905d2e">RegisterEventObserver</a> (<a class="el" href="class_pylon_1_1_data_processing_1_1_i_event_observer.html">IEventObserver</a> *pObserver)</td></tr>
<tr class="memdesc:abfab1c3de4499541b02ce60245905d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an event observer to the recipe.  <a href="#abfab1c3de4499541b02ce60245905d2e">More...</a><br /></td></tr>
<tr class="separator:abfab1c3de4499541b02ce60245905d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb5d9eb9c1efefee1d66f2e3c69457a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3cb5d9eb9c1efefee1d66f2e3c69457a">UnregisterEventObserver</a> ()</td></tr>
<tr class="memdesc:a3cb5d9eb9c1efefee1d66f2e3c69457a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any registered event observer from the recipe.  <a href="#a3cb5d9eb9c1efefee1d66f2e3c69457a">More...</a><br /></td></tr>
<tr class="separator:a3cb5d9eb9c1efefee1d66f2e3c69457a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4741419456a69e09dc7bff3e851d5148"><td class="memItemLeft" align="right" valign="top">CLock &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148">GetLock</a> ()</td></tr>
<tr class="memdesc:a4741419456a69e09dc7bff3e851d5148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the lock used for synchronizing the access to the recipe.  <a href="#a4741419456a69e09dc7bff3e851d5148">More...</a><br /></td></tr>
<tr class="separator:a4741419456a69e09dc7bff3e851d5148"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides convenient access to a data processing design described by a recipe file. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a29cc39040b471c8f0e5a19244d6f488a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29cc39040b471c8f0e5a19244d6f488a">&#9670;&nbsp;</a></span>CRecipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Pylon::DataProcessing::CRecipe::CRecipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> object with no recipe loaded. </p>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions. </dd></dl>

</div>
</div>
<a id="a88ef328bf834b8afafea7607321d0f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ef328bf834b8afafea7607321d0f7e">&#9670;&nbsp;</a></span>~CRecipe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Pylon::DataProcessing::CRecipe::~CRecipe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys a <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> object. </p>
<p>Calls <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3be612910e571e5b17c29c761f94d34d" title="Unloads the recipe currently loaded. ">Unload()</a></code> for cleaning up if any recipe is currently loaded.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af72bb3d2294a694e563c9dd4b3f9ecc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72bb3d2294a694e563c9dd4b3f9ecc2">&#9670;&nbsp;</a></span>CanTriggerUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::CanTriggerUpdate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether triggering an update is possible. </p>
<p>An update can't be triggered if the recipe is not started or at least one connection connected to the input terminal has its queue mode set to blocking and there is no space available.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an update can be triggered, <code>false</code> otherwise.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a56ccde1d97df744b229e737b737c8d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ccde1d97df744b229e737b737c8d09">&#9670;&nbsp;</a></span>DeallocateResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::DeallocateResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates all resources used by the recipe. </p>
<p>Calls <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a5aac836a86698a2899f1db0cdaaef420" title="Finishes the data processing and deallocates all resources allocated at start. ">Stop()</a></code> if the design described by the recipe has been started.</p>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
No resources are allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a3b0f7764bdbbf30e65b9ea5e4214eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0f7764bdbbf30e65b9ea5e4214eee5">&#9670;&nbsp;</a></span>GetInputType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_pylon_1_1_data_processing.html#acba3cdc7c343bca3abe5bb6321249e55">EVariantDataType</a> Pylon::DataProcessing::CRecipe::GetInputType </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>inputFullName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the variant data type of the input pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputFullName</td><td>The identifier of the input pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variant data type of the input pin.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
An input pin with the name <code>inputFullName</code> must exist. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="ab7861a74e827b218bdefd5fd2c564a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7861a74e827b218bdefd5fd2c564a41">&#9670;&nbsp;</a></span>GetInputTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual String_t Pylon::DataProcessing::CRecipe::GetInputTypeName </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>inputFullName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type name of the input pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputFullName</td><td>The identifier of the input pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type name of the input pin.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
An input pin with the name <code>inputFullName</code> must exist. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a4741419456a69e09dc7bff3e851d5148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4741419456a69e09dc7bff3e851d5148">&#9670;&nbsp;</a></span>GetLock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLock&amp; Pylon::DataProcessing::CRecipe::GetLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the lock used for synchronizing the access to the recipe. </p>
<p>This lock can be used when extending the Recipe class.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">class </span>CMyRecipe : <span class="keyword">public</span> <a class="code" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a29cc39040b471c8f0e5a19244d6f488a">CRecipe</a></div><div class="line">{</div><div class="line">    <span class="comment">// Method extending the Instant Camera class.</span></div><div class="line">    <span class="keywordtype">void</span> Foo()</div><div class="line">    {</div><div class="line">        <span class="comment">// Scoped Lock.</span></div><div class="line">        AutoLock lock( <a class="code" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148">CRecipe::GetLock</a>());</div><div class="line"></div><div class="line">        <span class="comment">//...</span></div><div class="line">    }</div><div class="line"> };</div></div><!-- fragment --><dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions. </dd></dl>

</div>
</div>
<a id="acf24f812c92e0dda89e100c61699f7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf24f812c92e0dda89e100c61699f7e4">&#9670;&nbsp;</a></span>GetOutputNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Pylon::DataProcessing::CRecipe::GetOutputNames </td>
          <td>(</td>
          <td class="paramtype">StringList_t &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the count and the list of names of all output pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>The list of output pin names of the recipe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of output pin names of the recipe.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="aadfcdbdf21de387fc6b58ff0279d6e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfcdbdf21de387fc6b58ff0279d6e51">&#9670;&nbsp;</a></span>GetOutputType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_pylon_1_1_data_processing.html#acba3cdc7c343bca3abe5bb6321249e55">EVariantDataType</a> Pylon::DataProcessing::CRecipe::GetOutputType </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>outputFullName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the variant data type of the output pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFullName</td><td>The identifier of the output pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variant data type of the output pin.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
An output pin with the name <code>outputFullName</code> must exist. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a621e1b8fad3dd2a8b29e7fd0ae19ca02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621e1b8fad3dd2a8b29e7fd0ae19ca02">&#9670;&nbsp;</a></span>GetOutputTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual String_t Pylon::DataProcessing::CRecipe::GetOutputTypeName </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>outputFullName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type name of the output pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFullName</td><td>The name of the output pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The type name of the output pin.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
An output pin with the name <code>outputFullName</code> must exist. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a6e67cf77c109f3f48f96ccc356cc20d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e67cf77c109f3f48f96ccc356cc20d9">&#9670;&nbsp;</a></span>GetParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_pylon_1_1_data_processing_1_1_i_parameter_collection.html">IParameterCollection</a>&amp; Pylon::DataProcessing::CRecipe::GetParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a parameter collection to access the parameters of the recipe. </p>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="struct_pylon_1_1_data_processing_1_1_i_parameter_collection.html" title="Interface to access the parameter collection. ">IParameterCollection</a></code> returns objects based on <code>CParameter</code> that can be used while a recipe is loaded. Before unloading a recipe, the parameter objects must be cleared by calling <code>CParameter::Release()</code>. For parameters that become available only when resources are allocated, e.g., a camera, <code>CParameter::Release()</code> must be called before deallocating a resource.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <code><a class="el" href="struct_pylon_1_1_data_processing_1_1_i_parameter_collection.html" title="Interface to access the parameter collection. ">IParameterCollection</a></code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A recipe is loaded. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a4b485de46abb1dc4f1bd6abf4a3bdb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b485de46abb1dc4f1bd6abf4a3bdb95">&#9670;&nbsp;</a></span>GetRecipeContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual intptr_t Pylon::DataProcessing::CRecipe::GetRecipeContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the context. </p>
<p>This is useful when handling multiple recipes.</p>
<p>You can access the context using <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4b485de46abb1dc4f1bd6abf4a3bdb95" title="Returns the context. ">GetRecipeContext()</a></code>, e.g., in <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html#aaf48fcfbdba38f38c241e8f6992388f8" title="This method is called when an output of the CRecipe pushes data out. ">IOutputObserver::OutputDataPush()</a></code>, when receiving data from multiple recipes.</p>
<dl class="section return"><dt>Returns</dt><dd>The context.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a99a6b99b08f637b0dbf225ebb1a4e9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a6b99b08f637b0dbf225ebb1a4e9ff">&#9670;&nbsp;</a></span>HasInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::HasInput </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>inputFullName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether an input pin is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputFullName</td><td>The identifier of the input pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the input pin is available.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a93725db38c5411cdfb576dcf0d7a992d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93725db38c5411cdfb576dcf0d7a992d">&#9670;&nbsp;</a></span>HasOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::HasOutput </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>outputFullName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether an output pin is available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFullName</td><td>The identifier of the output pin.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the output pin is available.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a9c575281e0357133c1165ec72fcacf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c575281e0357133c1165ec72fcacf5b">&#9670;&nbsp;</a></span>IsLoaded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::IsLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a recipe is loaded. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a recipe is loaded.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a0a045db5cb05b34c9f421a432c9abe33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a045db5cb05b34c9f421a432c9abe33">&#9670;&nbsp;</a></span>IsStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::IsStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about the recipe being started. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the recipe has been started.</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="ade704260929c747515bb726e7f29612f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade704260929c747515bb726e7f29612f">&#9670;&nbsp;</a></span>Load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::Load </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a recipe from disk and creates the objects of the design described by the recipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The name and path of the recipe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The given file name must be a valid file path of an existing file containing valid recipe data. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
A recipe is loaded. You can use <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a9c575281e0357133c1165ec72fcacf5b" title="Checks whether a recipe is loaded. ">IsLoaded()</a></code> to check whether a recipe is loaded. Implicitly calls <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3be612910e571e5b17c29c761f94d34d" title="Unloads the recipe currently loaded. ">Unload()</a></code> and unregisters all observers already connected. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the recipe can't be loaded. No recipe is loaded if an error occurred.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="ad4975c952bae69337e6b7e74c38b3f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4975c952bae69337e6b7e74c38b3f15">&#9670;&nbsp;</a></span>LoadFromBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::LoadFromBinary </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a recipe from binary buffer and creates the objects of the design described by the recipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pBuffer</td><td>Buffer pointer to binary recipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>Buffer size for binary recipe buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The buffer specified by pBuffer and bufferSize must contain valid recipe data. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
A recipe is loaded. You can use <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a9c575281e0357133c1165ec72fcacf5b" title="Checks whether a recipe is loaded. ">IsLoaded()</a></code> to check whether a recipe is loaded. Implicitly calls <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3be612910e571e5b17c29c761f94d34d" title="Unloads the recipe currently loaded. ">Unload()</a></code> and unregisters all observers already connected. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the recipe can't be loaded. No recipe is loaded if an error occurred.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="ade90b70669f92e86760d60c20a5be771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade90b70669f92e86760d60c20a5be771">&#9670;&nbsp;</a></span>PreAllocateResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::PreAllocateResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional method to pre-allocate resources. </p>
<p>All resources that could be allocated successfully stay allocated until a call to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a56ccde1d97df744b229e737b737c8d09" title="Deallocates all resources used by the recipe. ">DeallocateResources()</a></code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A recipe is loaded. </li>
<li>
The recipe must not be started. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
All resources are allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if: <ul>
<li>
The preconditions are not met. </li>
<li>
The resources couldn't be allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a39eb91753ef439806df763f3812ab739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb91753ef439806df763f3812ab739">&#9670;&nbsp;</a></span>RegisterAllOutputsObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::RegisterAllOutputsObserver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERegistrationMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an output observer to the list of registered output observers. </p>
<p>If <code>mode</code> equals <code>RegistrationMode_ReplaceAll</code>, the list of registered observes is cleared.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
The observer must not be deleted before the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> is destroyed while it is registered. </li>
<li>
If the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html" title="An interface that can be used to receive output data from a CRecipe. ">IOutputObserver</a></code> and the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> are created on the stack in the same scope, the observer must be created prior to the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> it is registered to because the objects are destroyed in reverse order. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>The receiver of events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates how to register the new observer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A recipe is loaded. </li>
<li>
<code>pObserver</code> is not nullptr. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The observer is registered and called when any output data is available. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="abfab1c3de4499541b02ce60245905d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfab1c3de4499541b02ce60245905d2e">&#9670;&nbsp;</a></span>RegisterEventObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::RegisterEventObserver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_event_observer.html">IEventObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an event observer to the recipe. </p>
<p>Only one single observer per recipe is supported. Registering a new one automatically unregisters the old one. Registered observers must be unregistered before destruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>The receiver of events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
<code>pObserver</code> is not nullptr. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The observer is registered and called when events occur, e.g., an error is detected by a vTool. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal lock for event observer handling. </dd></dl>

</div>
</div>
<a id="adf711895119c2a82bf9a0bbbfad31ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf711895119c2a82bf9a0bbbfad31ee0">&#9670;&nbsp;</a></span>RegisterOutputObserver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::RegisterOutputObserver </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>outputFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERegistrationMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an output observer to the list of registered output observers. </p>
<p>If mode equals <code>RegistrationMode_ReplaceAll</code>, the list of registered observes is cleared.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
The observer must not be deleted before the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> is destroyed while it is registered. </li>
<li>
If the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html" title="An interface that can be used to receive output data from a CRecipe. ">IOutputObserver</a></code> and the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> are created on the stack in the same scope, the observer must be created prior to the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> it is registered to because the objects are destroyed in reverse order. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFullName</td><td>The name of the output pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>The receiver of events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates how to register the new observer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events.. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A recipe is loaded. </li>
<li>
The output pin exists. </li>
<li>
<code>pObserver</code> is not nullptr. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The observer is registered and called when output data is available. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a1b0d02363ba4c13b26af72d3a9790d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0d02363ba4c13b26af72d3a9790d7e">&#9670;&nbsp;</a></span>RegisterOutputObserver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::RegisterOutputObserver </td>
          <td>(</td>
          <td class="paramtype">const StringList_t &amp;&#160;</td>
          <td class="paramname"><em>outputFullNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERegistrationMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an output observer to the list of registered output observers. </p>
<p>If <code>mode</code> equals <code>RegistrationMode_ReplaceAll</code>, the list of registered observes is cleared.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>
The observer must not be deleted before the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> is destroyed while it is registered. </li>
<li>
If the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html" title="An interface that can be used to receive output data from a CRecipe. ">IOutputObserver</a></code> and the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> are created on the stack in the same scope, the observer must be created prior to the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">CRecipe</a></code> it is registered to because the objects are destroyed in reverse order. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFullNames</td><td>A list of names of the observed output pins. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>The receiver of events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>Indicates how to register the new observer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A recipe is loaded. </li>
<li>
The output pins exist. </li>
<li>
<code>pObserver</code> is not nullptr. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The observer is registered and called when output data is available. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a327e0ed4bfe8f223d8e4aeeb38b70bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327e0ed4bfe8f223d8e4aeeb38b70bc4">&#9670;&nbsp;</a></span>SetRecipeContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::SetRecipeContext </td>
          <td>(</td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a context. </p>
<p>This is useful when handling multiple recipes.</p>
<p>You can access the context using <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4b485de46abb1dc4f1bd6abf4a3bdb95" title="Returns the context. ">GetRecipeContext()</a></code>, e.g., in <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html#aaf48fcfbdba38f38c241e8f6992388f8" title="This method is called when an output of the CRecipe pushes data out. ">IOutputObserver::OutputDataPush()</a></code>, when receiving data from multiple recipes.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a3a89e0690875436aa185b22854cd8747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a89e0690875436aa185b22854cd8747">&#9670;&nbsp;</a></span>Start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares the data processing and allocates resources required by the design. </p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
A recipe is loaded. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>The recipe is not started if an error occurred. Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a5aac836a86698a2899f1db0cdaaef420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aac836a86698a2899f1db0cdaaef420">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::Stop </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em> = <code>waitForever</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes the data processing and deallocates all resources allocated at start. </p>
<p>Updates may accumulate at some places in the design, e.g., when updates are triggered more frequently than can be processed and the queue mode of the connections is not set properly. <code>timeoutMs</code> describes the time these accumulated updates are tolerated before they will be cleared. Updates that are already being processed by a vTool will not be aborted when the timeout expires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>Time to wait for updates not yet started to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
The recipe is stopped. </li>
<li>
Resources allocated when calling <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3a89e0690875436aa185b22854cd8747" title="Prepares the data processing and allocates resources required by the design. ">Start()</a></code> are deallocated. </li>
<li>
Resources allocated when calling <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ade90b70669f92e86760d60c20a5be771" title="Optional method to pre-allocate resources. ">PreAllocateResources()</a></code> are still allocated. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="aad48ebe617dc0dc30b8afa255c8fb48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad48ebe617dc0dc30b8afa255c8fb48e">&#9670;&nbsp;</a></span>TriggerUpdate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a> Pylon::DataProcessing::CRecipe::TriggerUpdate </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>inputFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ETimeoutHandling&#160;</td>
          <td class="paramname"><em>timeoutHandling</em> = <code>TimeoutHandling_ThrowException</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts an update in a blocking call for a single input pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputFullName</td><td>The name of the input pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to feed the input pin with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>The timeout for the update to finish completely. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutHandling</td><td>If timeoutHandling equals TimeoutHandling_ThrowException, a timeout exception is thrown on timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>An optional observer to notify when the update has been processed completely. This doesn't include subsequent updates triggered by this update. This depends on the vTools used in the recipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The update object that has been produced by this call.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The recipe is started. </li>
<li>
The input pin exists. </li>
<li>
The type of the <code>value</code> is compatible with the input data type. </li>
<li>
<code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#af72bb3d2294a694e563c9dd4b3f9ecc2" title="Checks whether triggering an update is possible. ">CanTriggerUpdate()</a></code> must return <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met. Throws an exception if the update could not be processed in the time specified by <code>timeoutMs</code> and <code>timeoutHandling</code> == TimeoutHandling_ThrowException.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code> while not waiting for the update to finish completely. </dd></dl>

</div>
</div>
<a id="ab6073cbb325416a05898146e79e8a667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6073cbb325416a05898146e79e8a667">&#9670;&nbsp;</a></span>TriggerUpdate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a> Pylon::DataProcessing::CRecipe::TriggerUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant_container.html">CVariantContainer</a>&#160;</td>
          <td class="paramname"><em>inputCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ETimeoutHandling&#160;</td>
          <td class="paramname"><em>timeoutHandling</em> = <code>TimeoutHandling_ThrowException</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts an update in a blocking call for a number of input pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputCollection</td><td>Provides the input names and the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutMs</td><td>The timeout for the update to finish completely. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeoutHandling</td><td>If timeoutHandling equals TimeoutHandling_ThrowException, a timeout exception is thrown on timeout. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>An optional observer to notify when the update has been processed completely. This doesn't include subsequent updates triggered by this update. This depends on the vTools used in the recipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The update object that has been produced by this call.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The recipe is started. </li>
<li>
The argument <code>inputCollection</code> must not be empty. </li>
<li>
The input pins exist. </li>
<li>
The types of the values in <code>inputCollection</code> are compatible with the input data types. </li>
<li>
<code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#af72bb3d2294a694e563c9dd4b3f9ecc2" title="Checks whether triggering an update is possible. ">CanTriggerUpdate()</a></code> must return <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met. Throws an exception if the update could not be processed in the time specified by <code>timeoutMs</code> and <code>timeoutHandling</code> == TimeoutHandling_ThrowException.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code> while not waiting for the update to finish completely. </dd></dl>

</div>
</div>
<a id="a249a35e407a87c9e1ccfcb37ec31b8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249a35e407a87c9e1ccfcb37ec31b8aa">&#9670;&nbsp;</a></span>TriggerUpdateAsync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a> Pylon::DataProcessing::CRecipe::TriggerUpdateAsync </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>inputFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts an update asynchronously for a single input pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputFullName</td><td>The name of the input pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to feed the input pin with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>Optionally, the observer to notify when the update has been processed completely. This doesn't include subsequent updates triggered by this update. This depends on the vTools used in the recipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The update object that has been produced by this call.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The recipe is started. </li>
<li>
The input pin exists. </li>
<li>
The type of the <code>value</code> is compatible with the input data type. </li>
<li>
<code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#af72bb3d2294a694e563c9dd4b3f9ecc2" title="Checks whether triggering an update is possible. ">CanTriggerUpdate()</a></code> must return <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="aec1947c2a557f26a047bac2e8bc27bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1947c2a557f26a047bac2e8bc27bb7">&#9670;&nbsp;</a></span>TriggerUpdateAsync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a> Pylon::DataProcessing::CRecipe::TriggerUpdateAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant_container.html">CVariantContainer</a>&#160;</td>
          <td class="paramname"><em>inputCollection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html">IUpdateObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts an update asynchronously for a number of input pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputCollection</td><td>Provides the input names and the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>An optional observer to notify when the update has been processed completely. This doesn't include subsequent updates triggered by this update. This depends on the vTools used in the recipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. This ID is provided to <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_update_observer.html#a6ae01d0676abc4063b6f18aae8ddc432" title="This method is called when an update of a Pylon::DataProcessing::CRecipe has been processed completel...">IUpdateObserver::UpdateDone</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The update object that has been produced by this call.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
The recipe is started. </li>
<li>
The argument <code>inputCollection</code> must not be empty. </li>
<li>
The input pins exist. </li>
<li>
The types of the values in <code>inputCollection</code> are compatible with the input data types. </li>
<li>
<code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#af72bb3d2294a694e563c9dd4b3f9ecc2" title="Checks whether triggering an update is possible. ">CanTriggerUpdate()</a></code> must return <code>true</code>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Throws an exception if the preconditions are not met.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a3be612910e571e5b17c29c761f94d34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be612910e571e5b17c29c761f94d34d">&#9670;&nbsp;</a></span>Unload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::Unload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unloads the recipe currently loaded. </p>
<p>Calls <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a56ccde1d97df744b229e737b737c8d09" title="Deallocates all resources used by the recipe. ">DeallocateResources()</a></code> if the design described by the recipe has allocated resources. Unregisters all observers that have been connected.</p>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>
Data received via <code><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html#aaf48fcfbdba38f38c241e8f6992388f8" title="This method is called when an output of the CRecipe pushes data out. ">IOutputObserver::OutputDataPush</a></code> must be freed. </li>
</ul>
</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
No recipe is loaded. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="a3cb5d9eb9c1efefee1d66f2e3c69457a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb5d9eb9c1efefee1d66f2e3c69457a">&#9670;&nbsp;</a></span>UnregisterEventObserver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Pylon::DataProcessing::CRecipe::UnregisterEventObserver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any registered event observer from the recipe. </p>
<p>If an observer is not found, nothing is done.</p>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using an internal lock for event observer handling. </dd></dl>

</div>
</div>
<a id="a42533f9952f888103f804595cac1c976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42533f9952f888103f804595cac1c976">&#9670;&nbsp;</a></span>UnregisterOutputObserver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::UnregisterOutputObserver </td>
          <td>(</td>
          <td class="paramtype">const String_t &amp;&#160;</td>
          <td class="paramname"><em>outputFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an output observer from the list of registered output observers. </p>
<p>If the output pin or the observer with <code>userProvidedId</code> is not found, nothing is done.</p>
<dl class="section note"><dt>Note</dt><dd>The last registered observer with <code>userProvidedId</code> is unregistered first if the same observer with <code>userProvidedId</code> has been registered multiple times.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outputFullName</td><td>The name of the output pin. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>The receiver of events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. If an observer has been registered multiple times, the observer with the matching user id is deregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the output pin and the observer were found and the observer has been unregistered.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the output pin and the observer were found, the observer is unregistered. </li>
<li>
If an observer has been registered multiple times, the observer with the matching user ID is deregistered. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<a id="aff3fed78de3117ffdcca305cb787f65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3fed78de3117ffdcca305cb787f65e">&#9670;&nbsp;</a></span>UnregisterOutputObserver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Pylon::DataProcessing::CRecipe::UnregisterOutputObserver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> *&#160;</td>
          <td class="paramname"><em>pObserver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>userProvidedId</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an output observer from the list of registered output observers for all output pins. </p>
<p>If the observer with <code>userProvidedId</code> is not found, nothing is done.</p>
<dl class="section note"><dt>Note</dt><dd>The last registered observer with <code>userProvidedId</code> is unregistered first if the same observer with <code>userProvidedId</code> has been registered multiple times.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pObserver</td><td>The receiver of events. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userProvidedId</td><td>This optional ID is passed to distinguish between different events. If an observer has been registered multiple times, the observer with the matching user ID is deregistered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the output pin and the observer were found and the observer has been unregistered.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><ul>
<li>
If the output pin and the observer were found, the observer is unregistered. </li>
<li>
If an observer has been registered multiple times, the observer with the matching user ID is deregistered. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Error Safety:</dt><dd>Doesn't throw C++ exceptions.</dd></dl>
<dl class="section user"><dt>Thread Safety:</dt><dd>This method is synchronized using the lock provided by <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a4741419456a69e09dc7bff3e851d5148" title="Provides access to the lock used for synchronizing the access to the recipe. ">GetLock()</a></code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pylondataprocessing/<a class="el" href="_recipe_8h.html">Recipe.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<div style="font-size: 120%; margin-left: 10px;" id="projectname">pylon C++ Data Processing Programmer&#39;s Guide <span id="projectnumber">1.1.0</span></div>
<address style="margin-left: 10px;"><small>Copyright (c) 2022 <a href="http://www.baslerweb.com/" target="_blank">Basler AG</a> (Wed Jul 6 2022 08:23:49)</small></address>
</body>
</html>
