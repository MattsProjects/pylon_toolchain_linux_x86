<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pylon Application SDK: Programmer&#39;s Guide and API Reference for Linux</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="modified_doxygen-unix.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
</head>
<body>
<div id="TopBanner"><table width="100%"><tr>
    <td width="196px"><img src="Pylon_Logo.png" alt="Pylon Logo" width="196px"></td>
    <td width="99%"></td>
    <td width="184px"><img src="Basler_Logo.png" alt="Basler Logo" width="184px"></td>
</tr></table></div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">pylon C++ Data Processing Programmer&#39;s Guide</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Programmer's Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Getting Started</h2>
<p>The pylon data processing Programmer's Guide is a brief guide to programming using the Basler pylon Data Processing C++ API. It can be used together with the pylon Data Processing <a class="el" href="samplecodepage.html">sample code</a> to get started. In addition, the API reference provides documentation about the Basler pylon Data Processing C++ interface. The documentation of the interface is also available in the header files of pylon. When using Microsoft Visual Studio, right-click on the desired method or class and select 'Go To Declaration' from the context menu to go to the related documentation.</p>
<dl class="section note"><dt>Note</dt><dd>The Basler pylon Data Processing API for C++ extends the pylon C++ image acquisition API. The documentation for the pylon C++ image acquisition API can be found in the "C++ Programmer's Guide and Reference Documentation".</dd></dl>
<h2>Settings for Building Applications with pylon Data Processing</h2>
<p>The pylon data processing samples are provided with <a href="https://cmake.org/" target="_blank">CMake</a> build files that show you how to set up build files for an application. If you want to use a different build system, you need to set up your build sytem for the pylon C++ API first. The "C++ Programmer's Guide and Reference Documentation" shows you how to do that. You also need to add the include files found in the include\pylondataprocessing folder and link the PylonDataProcessing dynamic link library.</p>
<h2>Debugging pylon Applications Using GigE Cameras</h2>
<p>When debugging a pylon application using GigE cameras, you may encounter heartbeat timeouts. The application must send special network packets to the camera in defined intervals. If the camera doesn't receive these heartbeats, it will consider the connection as broken and won't accept any commands from the application. Because of this, you have to set the heartbeat timeout of a camera to a higher value when debugging. The "C++ Programmer's Guide and Reference Documentation" shows you how to do that.</p>
<h2>Initialization/Uninitialization of the pylon Runtime Library</h2>
<p>The pylon runtime system must be initialized before use. A pylon-based application must call the <code>PylonInitialize()</code> method before using any other functions of the pylon runtime system. Before an application exits, it must call the <code>PylonTerminate()</code> method to free resources allocated by the pylon runtime system.</p>
<p>The <code>Pylon::PylonAutoInitTerm</code> convenience class helps you to do the above. The constructor of <code>PylonAutoInitTerm</code> calls <code>PylonInitialize()</code>, and the destructor calls <code>PylonTerminate()</code>. This ensures that the pylon runtime system is initialized during the lifetime of an object of the <code>PylonAutoInitTerm</code> type.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pylon/PylonIncludes.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_pylon.html">Pylon</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line"></div><div class="line">  Pylon::PylonAutoInitTerm autoInitTerm;  <span class="comment">// PylonInitialize() will be called now</span></div><div class="line"></div><div class="line">  <span class="comment">// Use pylon</span></div><div class="line">  <span class="comment">// ..</span></div><div class="line"></div><div class="line">}  <span class="comment">// autoInitTerm&#39;s destructor calls PylonTerminate() now</span></div></div><!-- fragment --><h2>Error Handling</h2>
<p>In case of errors, the methods of pylon classes may throw C++ exceptions. The pylon C++ API throws exceptions of the <code>GenericException</code> type that are subclasses of GenericException. You should guard pylon calls with exception handlers for catching <code>GenericException</code>. Example: </p><div class="fragment"><div class="line"><span class="keywordflow">try</span></div><div class="line">{</div><div class="line">  camera.Width.SetValue( 640 );</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> GenericException &amp; e)</div><div class="line">{</div><div class="line">  cerr &lt;&lt; <span class="stringliteral">&quot;Failed to set the AOI width. Reason: &quot;</span></div><div class="line">  &lt;&lt; e.GetDescription() &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><h2>Recipe</h2>
<p>The starting point for getting to know the pylon Data Processing C++ API and for using vTools in your application code is the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html">CRecipe</a> class. vTools are the building blocks for creating data processing designs using the Workbench of the pylon Viewer. ata processing designs are saved in recipe documents. Prior to using the pylon Data Processing C++ API, you need to create a data processing design and save it as a recipe document in the Workbench. A recipe document contains information about the vTools used, information about how the vTools are connected, and further settings. MMore information about creating recipe documents can be found <a href="https://docs.baslerweb.com/overview-of-the-workbench.html" target="_blank">here</a>.</p>
<p>The <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html">CRecipe</a> class represents a recipe document created by the pylon Viewer Workbench and allows you to run and parameterize vTools. The CRecipe() class can't be used to create recipes.</p>
<h3>vTools</h3>
<p>There is no representation for vTools in the pylon Data Processing C++ API. The <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html">CRecipe</a> class allows you to parameterize vTools. See the <a class="el" href="programmersguidepage.html#parameterizingvtools">Parameterizing vTools</a> section for more information.</p>
<h3>Connections</h3>
<p>There is no representation for a connection in the pylon Data Processing C++ API. Connections are implemented as a queue. The way queues are parameterized has a large impact on how a workflow is executed. A connection can only be parameterized via the pylon Workbench.</p>
<h3>Input and Output Terminals</h3>
<p>The input and output terminals (the gray bars with the '+' icon in a circle) represent the inputs and outputs of a recipe. There is no class representing an input or an output terminal in the pylon Data Processing C++ API. The identifiers of the pins of an input or an output terminal are used by the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">Pylon::DataProcessing::CRecipe</a> class, e.g., for getting the output data. This is shown in the <a class="el" href="programmersguidepage.html#processoutputdata">Process Output Data</a> section.</p>
<dl class="section note"><dt>Note</dt><dd>You can only push data values to a vTool via the input terminal and you can only receive data values from a vTool via the output terminal.</dd></dl>
<h3>Recipe State Changes</h3>
<p>Using the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html">CRecipe</a> class can be broken down into consecutive steps. Each step changes the state of the CRecipe class.</p>
<h4>Creating a Recipe</h4>
<p>The following example illustrates how to <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a29cc39040b471c8f0e5a19244d6f488a">create a recipe object</a>. The next step is loading a recipe document.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a recipe representing a design created using</span></div><div class="line"><span class="comment">// the pylon Viewer Workbench.</span></div><div class="line">CRecipe recipe;</div></div><!-- fragment --><h4>Loading a Recipe Document</h4>
<p>A recipe file can be <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ade704260929c747515bb726e7f29612f">loaded</a> by simply passing the file name. You can also <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ad4975c952bae69337e6b7e74c38b3f15">load a recipe from memory</a> by passing the recipe file contents as a buffer. Loading a recipe instantiates all vTools.</p>
<div class="fragment"><div class="line"><span class="comment">// Load the recipe file.</span></div><div class="line"><span class="comment">// Note: PYLON_DATAPROCESSING_CAMERA_RECIPE is a string</span></div><div class="line"><span class="comment">// created by the CMake build files.</span></div><div class="line">recipe.Load(PYLON_DATAPROCESSING_CAMERA_RECIPE);</div></div><!-- fragment --><p>After loading a recipe file, you can configure some parameters of certain vTools. Which parameters can be configured depends on the vTool. It is especially important to configure parameters that influence the allocation of resources, e.g., for selecting which camera device is used. See the <a class="el" href="programmersguidepage.html#parameterizingvtools">Parameterizing vTools</a> section for more information about parameterization.</p>
<p>You can get a list of all available parameters at this state using the following example. </p><div class="fragment"><div class="line"><span class="comment">// Print available parameters.</span></div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Parameter names before allocating resources&quot;</span> &lt;&lt; endl;</div><div class="line">    StringList_t parameterNames = recipe.GetParameters().GetAllParameterNames();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; name : parameterNames)</div><div class="line">    {</div><div class="line">        cout &lt;&lt; name &lt;&lt; endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Some vTools require a license. If no license is found, the loading of the recipe will fail by raising an exception.</dd></dl>
<h4>Preallocating Resources</h4>
<p>After loading a recipe and optionally setting parameters that influence the allocation of resources, you can <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ade90b70669f92e86760d60c20a5be771">allocate</a> resource. These are usally devices that require exclusive access, e.g., camera devices. The allocation of resources at this step also speeds up the following step of starting the recipe. Preallocating resources is an optional step. You can start a recipe whithout it.</p>
<div class="fragment"><div class="line"><span class="comment">// Allocate the required resources. This includes the camera device.</span></div><div class="line">recipe.PreAllocateResources();</div></div><!-- fragment --><p>You can get a list of all available parameters at this state using the following example. Usually, additional parameters become available after allocating the resources. </p><div class="fragment"><div class="line"><span class="comment">// Print available parameters after allocating resources. Now we can access the camera parameters.</span></div><div class="line">{</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Parameter names after allocating resources&quot;</span> &lt;&lt; endl;</div><div class="line">    StringList_t parameterNames = recipe.GetParameters().GetAllParameterNames();</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; name : parameterNames)</div><div class="line">    {</div><div class="line">        cout &lt;&lt; name &lt;&lt; endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h4>Starting a Recipe</h4>
<p>Before starting a recipe, you need to register at least one output observer for receiving data. See the <a class="el" href="programmersguidepage.html#processoutputdata">Process Output Data after an Update</a> section below for more information about receiving data. <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3a89e0690875436aa185b22854cd8747">Starting</a> the recipe, automatically allocates more resources if required. Now the recipe is ready for processing updates of the recipe. See the <a class="el" href="programmersguidepage.html#updates">Updates</a> section below for more information about updates.</p>
<div class="fragment"><div class="line"><span class="comment">// Start the processing.</span></div><div class="line">recipe.Start();</div></div><!-- fragment --><p>After the recipe has been started, you can optionally trigger the processing of updates by pushing data to the input terminal pins. See the <a class="el" href="programmersguidepage.html#providinginputdata">Providing Input Data and Trigger Updates</a> section below for more information.</p>
<h4>Stopping a Recipe</h4>
<p><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a5aac836a86698a2899f1db0cdaaef420">Stopping</a> the recipe automatically deallocates all resources that were allocated at starting. Now the recipe has stopped processing updates of the recipe.</p>
<dl class="section attention"><dt>Attention</dt><dd>After stopping and then deallocating resources, parameters of deallocated objects that have been acquired before must not be used anymore. See <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a6e67cf77c109f3f48f96ccc356cc20d9">Recipe::GetParameters()</a> for more information.</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// Stop the processing.</span></div><div class="line">recipe.Stop();</div></div><!-- fragment --><h4>Deallocating Resources</h4>
<p><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a56ccde1d97df744b229e737b737c8d09">Deallocating resources</a> releases all resources that have been allocated when calling <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#ade90b70669f92e86760d60c20a5be771">PreAllocateResources()</a>. If the recipe is in the 'started' state, it is stopped automatically so that the resources can be released.</p>
<div class="fragment"><div class="line">recipe.DeallocateResources();</div></div><!-- fragment --><dl class="section attention"><dt>Attention</dt><dd>After deallocating resources, parameters of deallocated objects that have been acquired before, must not be used anymore. See <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a6e67cf77c109f3f48f96ccc356cc20d9">Recipe::GetParameters()</a> for more information.</dd></dl>
<h4>Unloading a Recipe</h4>
<p><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3be612910e571e5b17c29c761f94d34d">Unloading</a> releases all resources by calling <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a56ccde1d97df744b229e737b737c8d09">DeallocateResources()</a>. All registered update or output observers are unregistered automatically because they must fit the recipe currently loaded. The next recipe loaded could be different.</p>
<div class="fragment"><div class="line">recipe.Unload();</div></div><!-- fragment --><h4>Destroying a Recipe</h4>
<p><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html">Destroying a recipe object</a> automatically calls <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a3be612910e571e5b17c29c761f94d34d">Unload()</a>. This automatically triggers the stopping of the recipe and the deallocation of resources.</p>
<p>The processing of vTools is data-driven. In addition, the pylon data processing uses the concept of updates. An update of a recipe consists of the synchronized processing of a defined set of data values, e.g., an image value and a double value. The processing can be performed by one vTool or multiple vTools concurrently. An update operation of the recipe is modelled in the pylon Data Processing C++ API by providing instances of the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_update.html">CUpdate</a> class. All updates are processed in a defined order. The CUpdate class can be used to check the order of execution by using the 'less-than' operator of the CUpdate class. In addition, you can check whether data values corresponding to one update belong together by using the 'equals' operator of the CUpdate class.</p>
<p>A vTool can process updates of the vTool triggered by a set of data values provided via the input pins or produce updates by providing a set of data values via the output pins, or both. A set of data values must consist of at least one data value. Most vTools simply process one update by processing a set of data values provided via the input pins and push out a new set of data values via the ouput pins, e.g., the Barcode Reader vTool. No new update is produced in this case. The Camera vTool produces one update each time an image is grabbed by providing the image as a value via its output pin.</p>
<p>Data values provided via the input and output terminals of the recipe are transported by being wrapped in an object of the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a> class. The CVariant class can wrap the data types listed by the <a class="el" href="namespace_pylon_1_1_data_processing.html#acba3cdc7c343bca3abe5bb6321249e55">EVariantDataType</a> enumeration. Besides basic data types like VariantDataType_Float value (C++ type double), the CVariant class can also wrap arrays of data values and structure them as nested data structures composed of basic data types, e.g., PointF. A PointF, for example, provides two named subvalues, i.e., "X" and "Y", of type VariantDataType_Float. (See the <a class="el" href="programmersguidepage.html#compositedatatypes">Composite Data Types</a> section for more information.)</p>
<h3>Data Errors</h3>
<p>If something doesn't work as expected when processing data, e.g., an image is grabbed incompletely, data values must still flow through the recipe. This is neccessary to trigger further actions, e.g., for handling errors. Therefore, your must check whether output data is valid before using it. This can be done by using the CVariant methods <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html#a1a11c43851cb3a1945283c1ca0e3f192">HasError()</a> and <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html#ae7ee85a5e64c1928c59c257fc1422f0a">GetErrorDescription()</a>.</p>
<h3>Sets of Data Values</h3>
<p>A set of data values provided via the input and output terminals of the recipe is transported by being wrapped in an object of the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant_container.html">CVariantContainer</a> class. The CVariantContainer works like a dictionary, e.g., like the std::map, organized as key/value pairs. The keys are strings containing the name of an input pin or an output pin of a recipe. A value is provided as a <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a> object.</p>
<h3>Data Arrays</h3>
<p>The following example illustrates how to access arrays:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i = 0; i &lt; value.<a class="code" href="class_pylon_1_1_data_processing_1_1_c_variant.html#a2c47666d4736fa01378f9cc4ee2a3c74">GetNumArrayValues</a>(); ++i)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> CVariant decodedBarcodeValue = value.<a class="code" href="class_pylon_1_1_data_processing_1_1_c_variant.html#a13e94078a3eb15064632d67d822accf4">GetArrayValue</a>(i);</div><div class="line">    <span class="keywordflow">if</span> (!decodedBarcodeValue.HasError())</div><div class="line">    {</div><div class="line">        currentResultData.decodedBarcodes.push_back(decodedBarcodeValue.ToString());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        currentResultData.hasError = <span class="keyword">true</span>;</div><div class="line">        currentResultData.errorMessage = value.<a class="code" href="class_pylon_1_1_data_processing_1_1_c_variant.html#ae7ee85a5e64c1928c59c257fc1422f0a">GetErrorDescription</a>();</div><div class="line">        <span class="keywordflow">break</span>;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The code sample above can be found in the <a class="el" href="samplecodepage.html#entire_sample_barcode">barcode</a> sample.</p>
<p>Output data is provided per callback using the <a class="el" href="class_pylon_1_1_data_processing_1_1_i_output_observer.html">IOutputObserver</a> interface after starting a recipe. The following example shows the use of the interface. The example also illustrates how to store the data in a queue for later processing by another thread.</p>
<div class="fragment"><div class="line"><span class="comment">// Declare a data class for one set of output data values.</span></div><div class="line"><span class="keyword">class </span>ResultData</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ResultData()</div><div class="line">        : hasError(false)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    CPylonImage image; <span class="comment">// The image from the camera</span></div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> hasError;     <span class="comment">// If something doesn&#39;t work as expected</span></div><div class="line">                       <span class="comment">// while processing data, this is set to true.</span></div><div class="line"></div><div class="line">    String_t errorMessage; <span class="comment">// Contains an error message if</span></div><div class="line">                           <span class="comment">// hasError has been set to true.</span></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// MyOutputObserver is a helper object that shows how to handle output data</span></div><div class="line"><span class="comment">// provided via the IOutputObserver::OutputDataPush interface method.</span></div><div class="line"><span class="comment">// Also, MyOutputObserver shows how a thread-safe queue can be implemented</span></div><div class="line"><span class="comment">// for later processing while pulling the output data.</span></div><div class="line"><span class="keyword">class </span>MyOutputObserver : <span class="keyword">public</span> IOutputObserver</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MyOutputObserver()</div><div class="line">        : m_waitObject(WaitObjectEx::Create())</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Implements IOutputObserver::OutputDataPush.</span></div><div class="line">    <span class="comment">// This method is called when an output of the CRecipe pushes data out.</span></div><div class="line">    <span class="comment">// The call of the method can be performed by any thread of the thread pool of the recipe.</span></div><div class="line">    <span class="keywordtype">void</span> OutputDataPush(</div><div class="line">        CRecipe&amp; recipe,</div><div class="line">        CVariantContainer valueContainer,</div><div class="line">        <span class="keyword">const</span> CUpdate&amp; update,</div><div class="line">        intptr_t userProvidedId)<span class="keyword"> override</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// The following variables are not used here:</span></div><div class="line">        PYLON_UNUSED(recipe);</div><div class="line">        PYLON_UNUSED(update);</div><div class="line">        PYLON_UNUSED(userProvidedId);</div><div class="line"></div><div class="line">        ResultData currentResultData;</div><div class="line"></div><div class="line">        <span class="comment">// Get the data provided by the recipe output pin &quot;Image&quot;.</span></div><div class="line">        <span class="comment">// The value container is a dictionary/map-like type.</span></div><div class="line">        <span class="comment">// Look for the key in the dictionary.</span></div><div class="line">        <span class="keyword">auto</span> pos = valueContainer.find(<span class="stringliteral">&quot;Image&quot;</span>);</div><div class="line">        <span class="comment">// We expect there to be an image</span></div><div class="line">        <span class="comment">// because this is the the only output pin of this recipe.</span></div><div class="line">        PYLON_ASSERT(pos != valueContainer.end());</div><div class="line">        <span class="keywordflow">if</span> (pos != valueContainer.end())</div><div class="line">        {</div><div class="line">            <span class="comment">// Now we can use the value of the key/value pair.</span></div><div class="line">            <span class="keyword">const</span> CVariant&amp; value = pos-&gt;second;</div><div class="line">            <span class="keywordflow">if</span> (!value.HasError())</div><div class="line">            {</div><div class="line">                currentResultData.image = value.ToImage();</div><div class="line">            }</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">            {</div><div class="line">                currentResultData.hasError = <span class="keyword">true</span>;</div><div class="line">                currentResultData.errorMessage = value.GetErrorDescription();</div><div class="line">            }</div><div class="line">        }</div><div class="line">        <span class="comment">// Add data to the result queue in a thread-safe way.</span></div><div class="line">        {</div><div class="line">            AutoLock scopedLock(m_memberLock);</div><div class="line">            m_queue.emplace_back(currentResultData);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Signal that data is ready.</span></div><div class="line">        m_waitObject.Signal();</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Get the wait object for waiting for data.</span></div><div class="line">    <span class="keyword">const</span> WaitObject&amp; GetWaitObject()</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> m_waitObject;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Get one result data object from the queue.</span></div><div class="line">    <span class="keywordtype">bool</span> GetResultData(ResultData&amp; resultDataOut)</div><div class="line">    {</div><div class="line">        AutoLock scopedLock(m_memberLock);</div><div class="line">        <span class="keywordflow">if</span> (m_queue.empty())</div><div class="line">        {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        resultDataOut = std::move(m_queue.front());</div><div class="line">        m_queue.pop_front();</div><div class="line">        <span class="keywordflow">if</span> (m_queue.empty())</div><div class="line">        {</div><div class="line">            m_waitObject.Reset();</div><div class="line">        }</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    CLock m_memberLock;        <span class="comment">// The member lock is required to ensure</span></div><div class="line">                               <span class="comment">// thread-safe access to the member variables.</span></div><div class="line">    WaitObjectEx m_waitObject; <span class="comment">// Signals that ResultData is available.</span></div><div class="line">                               <span class="comment">// It is set when m_queue is not empty.</span></div><div class="line">    list&lt;ResultData&gt; m_queue;  <span class="comment">// The queue of ResultData</span></div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The IOutputObserver is called from multiple internal threads of the <code><a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html" title="Provides convenient access to a data processing design described by a recipe file. ">Pylon::DataProcessing::CRecipe</a></code>.</dd></dl>
<p>The output observer needs to be registered after loading a recipe document and before starting the recipe.</p>
<div class="fragment"><div class="line"><span class="comment">// Register the helper object for receiving all output data.</span></div><div class="line">recipe.RegisterAllOutputsObserver(&amp;resultCollector, RegistrationMode_Append);</div></div><!-- fragment --><p>Updates can be triggered using the <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#aad48ebe617dc0dc30b8afa255c8fb48e">TriggerUpdate()</a> or <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a249a35e407a87c9e1ccfcb37ec31b8aa">TriggerUpdateAsync()</a> methods.</p>
<p>Data types can be basic data types or composite data types.</p>
<h3>Basic Data Types</h3>
<p>Basic data types, e.g., the C++ type 'double', are listed by the <a class="el" href="namespace_pylon_1_1_data_processing.html#acba3cdc7c343bca3abe5bb6321249e55">EVariantDataType</a> enumeration.</p>
<p>Data types like PointF or RectangleF, shown below, are composite data types. Composite data types can be composed of basic data types and other composite data types. The <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html">CVariant</a> class provides the functionality to obtain information about the composition and also provides access to the data. Subvalue names can be retrieved by <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html#ae4445919b15094b4cf8f6928c6cfd027">GetSubValueName()</a> with the help of <a class="el" href="class_pylon_1_1_data_processing_1_1_c_variant.html#af3bfa875fbba5cf9d9632fca4212abe0">GetNumSubValues()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> printSubValueNames(<span class="keyword">const</span> CVariant&amp; variant)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; variant.GetNumSubValues(); ++i)</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; variant.GetSubValueName(i) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The following example illustrates how to access the data of composite data types when you already know how it is composed, e.g., a RectangleF:</p>
<div class="fragment"><div class="line"><span class="comment">// The data from variant will be stored in the RectangleF struct</span></div><div class="line">ResultData::RectangleF rectangle;</div><div class="line"></div><div class="line"><span class="comment">// The center values are a nested composite data type. Because of that, the sub value &quot;X&quot; of &quot;Center&quot; is retrieved like a path</span></div><div class="line">rectangle.centerX = variant.GetSubValue(<span class="stringliteral">&quot;Center&quot;</span>).GetSubValue(<span class="stringliteral">&quot;X&quot;</span>).ToDouble();</div><div class="line">rectangle.centerY = variant.GetSubValue(<span class="stringliteral">&quot;Center&quot;</span>).GetSubValue(<span class="stringliteral">&quot;Y&quot;</span>).ToDouble();</div><div class="line"></div><div class="line"><span class="comment">// Width, height and rotation are sub values of the variant, so they can be directly accessed</span></div><div class="line">rectangle.width = variant.GetSubValue(<span class="stringliteral">&quot;Width&quot;</span>).ToUInt64();</div><div class="line">rectangle.height = variant.GetSubValue(<span class="stringliteral">&quot;Height&quot;</span>).ToUInt64();</div><div class="line">rectangle.rotation = variant.GetSubValue(<span class="stringliteral">&quot;Rotation&quot;</span>).ToDouble();</div></div><!-- fragment --><h3>PointF</h3>
<p>The PointF type provides the following subvalues: </p><table class="doxtable">
<tr>
<th>Name </th><th>Type </th><th>Unit </th><th>Variant Type  </th></tr>
<tr>
<td>X </td><td>double </td><td>m or px </td><td>VariantDataType_Float </td></tr>
<tr>
<td>Y </td><td>double </td><td>m or px </td><td>VariantDataType_Float </td></tr>
</table>
<p>PointF can provide image coordinates in pixels and world coordinates in meters. The origin (0,0) of image coordinates defined by a PointF is the center of the top left image pixel. Whether image coordinates in pixel or world coordinates in meters are used depends on the input or output terminal pin(s) used.</p>
<h3>RectangleF</h3>
<p>The RectangleF type provides the following subvalues: </p><table class="doxtable">
<tr>
<th>Name </th><th>Type </th><th>Unit </th><th>Variant Type  </th></tr>
<tr>
<td>Center </td><td>PointF </td><td>m or px </td><td>VariantDataType_Composite </td></tr>
<tr>
<td>Width </td><td>double </td><td>m or px </td><td>VariantDataType_Float </td></tr>
<tr>
<td>Height </td><td>double </td><td>m or px </td><td>VariantDataType_Float </td></tr>
<tr>
<td>Rotation </td><td>double </td><td>rad </td><td>VariantDataType_Float </td></tr>
</table>
<p>The rotation is defined relative to the x axis and rotates counterclockwise in radiant. Whether image coordinates in pixels or world coordinates in meters are used depends on the input or output terminal pin(s) used.</p>
<h3>Region</h3>
<p>The Region data type can't be accessed via the pylon Data Processing C++ API yet.</p>
<h3>Transformation</h3>
<p>The Transformation data type can't be accessed via the pylon Data Processing C++ API yet.</p>
<p>For vTool configuration, the pylon Data Processing C++ API uses the technologies defined by the GenICam standard. The parameters of all vTools are accessible via the parameter collection of the recipe. You can get the parameter collection by calling <a class="el" href="class_pylon_1_1_data_processing_1_1_c_recipe.html#a6e67cf77c109f3f48f96ccc356cc20d9">CRecipe::GetParameters()</a>. Internally, GenApi::INodeMap objects are used. See the "C++ Programmer's Guide and Reference Documentation" for more information about GenApi::INodeMap objects.</p>
<h3>Parameter Collections</h3>
<p>A parameter collection is represented by the <a class="el" href="struct_pylon_1_1_data_processing_1_1_i_parameter_collection.html">IParameterCollection</a> interface. A parameter collection represents a set of parameters that are identified by a path, a name, and a type.</p>
<p>The following code example illustrates how to access parameters: </p><div class="fragment"><div class="line"><span class="comment">// For demonstration purposes only</span></div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Selected camera device:&quot;</span> &lt;&lt; endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;ModelName=&quot;</span> &lt;&lt; recipe.GetParameters().Get(StringParameterName(<span class="stringliteral">&quot;MyCamera/@vTool/SelectedDeviceModelName&quot;</span>)).GetValueOrDefault(<span class="stringliteral">&quot;N/A&quot;</span>) &lt;&lt; std::endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;SerialNumber=&quot;</span> &lt;&lt; recipe.GetParameters().Get(StringParameterName(<span class="stringliteral">&quot;MyCamera/@vTool/SelectedDeviceSerialNumber&quot;</span>)).GetValueOrDefault(<span class="stringliteral">&quot;N/A&quot;</span>) &lt;&lt; std::endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;VendorName=&quot;</span> &lt;&lt; recipe.GetParameters().Get(StringParameterName(<span class="stringliteral">&quot;MyCamera/@vTool/SelectedDeviceVendorName&quot;</span>)).GetValueOrDefault(<span class="stringliteral">&quot;N/A&quot;</span>) &lt;&lt; std::endl;</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;UserDefinedName=&quot;</span> &lt;&lt; recipe.GetParameters().Get(StringParameterName(<span class="stringliteral">&quot;MyCamera/@vTool/SelectedDeviceUserDefinedName&quot;</span>)).GetValueOrDefault(<span class="stringliteral">&quot;N/A&quot;</span>) &lt;&lt; std::endl;</div></div><!-- fragment --><p>The following information must be provided to access a parameter: StringParameterName("MyCamera/@vTool/SelectedDeviceModelName")</p>
<ul>
<li>StringParameterName is the type of the parameter. Parameter name is required so that the compiler can return the corresponding pylon parameter class. You can find the parameter type in the Feature Documentation pane of the pylon Viewer.</li>
<li>MyCamera is the name of the vTool.</li>
<li>Use @vTool if you want to access the vTool parameters.</li>
<li>Use @CameraInstance if you want to access the parameters of the CInstantCamera object used internally. This applies to the Camera vTool only.</li>
<li>Use @DeviceTransportLayer if you want to access the transport layer parameters. This applies to the Camera vTool only.</li>
<li>Use @CameraDevice if you want to access the camera device parameters. This applies to the Camera vTool only.</li>
<li>Use @StreamGrabber0 if you want to access the camera stream grabber parameters. This applies to the Camera vTool only.</li>
<li>SelectedDeviceUserDefinedName is the name of the parameter. You can find the parameter names in the Feature Documentation pane of the pylon Viewer.</li>
</ul>
<p>The parameter names map to the following pylon C++ types. See the "C++ Programmer's Guide and Reference Documentation" for more information.</p>
<table class="doxtable">
<tr>
<th>Parameter Name </th><th>pylon API Type  </th></tr>
<tr>
<td>ParameterName </td><td>CParameter </td></tr>
<tr>
<td>IntegerParameterName </td><td>CIntegerParameter </td></tr>
<tr>
<td>FloatParameterName </td><td>CFloatParameter </td></tr>
<tr>
<td>StringParameterName </td><td>CStringParameter </td></tr>
<tr>
<td>BooleanParameterName </td><td>CBooleanParameter </td></tr>
<tr>
<td>ArrayParameterName </td><td>CArrayParameter </td></tr>
<tr>
<td>CommandParameterName </td><td>CCommandParameter </td></tr>
<tr>
<td>EnumParameterName </td><td>CEnumParameter </td></tr>
</table>
</div></div><!-- contents -->
<hr>
<div style="font-size: 120%; margin-left: 10px;" id="projectname">pylon C++ Data Processing Programmer&#39;s Guide <span id="projectnumber">1.1.0</span></div>
<address style="margin-left: 10px;"><small>Copyright (c) 2022 <a href="http://www.baslerweb.com/" target="_blank">Basler AG</a> (Wed Jul 6 2022 08:23:49)</small></address>
</body>
</html>
